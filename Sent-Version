import tkinter as tk
from tkinter import filedialog, messagebox
import random
import copy

# Superclass
class BaseSudoku:
    def __init__(self, board_size=9, subgrid_size=3, cell_size=50, max_wrong_attempts=3):
        self.BOARD_SIZE = board_size
        self.SUBGRID_SIZE = subgrid_size
        self.CELL_SIZE = cell_size
        self.MAX_WRONG_ATTEMPTS = max_wrong_attempts

    def create_grid(self, canvas):
        """วาดกริด Sudoku บน Canvas"""
        for i in range(self.BOARD_SIZE + 1):
            line_width = 3 if i % self.SUBGRID_SIZE == 0 else 1
            canvas.create_line(0, i * self.CELL_SIZE, self.CELL_SIZE * self.BOARD_SIZE, i * self.CELL_SIZE, width=line_width)
            canvas.create_line(i * self.CELL_SIZE, 0, i * self.CELL_SIZE, self.CELL_SIZE * self.BOARD_SIZE, width=line_width)

    def create_button(self, parent, text, command, row, column, colspan=1, pady=10):
        button = tk.Button(parent, text=text, command=command, state=tk.NORMAL)
        button.grid(row=row, column=column, columnspan=colspan, pady=pady)
        return button

# Model Class
class SudokuModel(BaseSudoku):
    def __init__(self):
        super().__init__()
        self.board = [[0 for _ in range(self.BOARD_SIZE)] for _ in range(self.BOARD_SIZE)]
        self.solution = None

    def is_valid(self, board, row, col, num):
        for i in range(self.BOARD_SIZE):
            if board[row][i] == num or board[i][col] == num:
                return False
        start_row = self.SUBGRID_SIZE * (row // self.SUBGRID_SIZE)
        start_col = self.SUBGRID_SIZE * (col // self.SUBGRID_SIZE)
        for i in range(self.SUBGRID_SIZE):
            for j in range(self.SUBGRID_SIZE):
                if board[start_row + i][start_col + j] == num:
                    return False
        return True

    def solve(self, board):
        for row in range(self.BOARD_SIZE):
            for col in range(self.BOARD_SIZE):
                if board[row][col] == 0:
                    nums = list(range(1, self.BOARD_SIZE + 1))
                    random.shuffle(nums)
                    for num in nums:
                        if self.is_valid(board, row, col, num):
                            board[row][col] = num
                            if self.solve(board):
                                return True
                            board[row][col] = 0
                    return False
        return True

    def generate_board(self):
        self.board = [[0 for _ in range(self.BOARD_SIZE)] for _ in range(self.BOARD_SIZE)]
        self.solve(self.board)
        self.solution = copy.deepcopy(self.board)
        self.remove_numbers()

    def remove_numbers(self, num_to_remove=30):
        removed = 0
        while removed < num_to_remove:
            row = random.randint(0, self.BOARD_SIZE - 1)
            col = random.randint(0, self.BOARD_SIZE - 1)
            if self.board[row][col] != 0:
                self.board[row][col] = 0
                removed += 1

    def generate_solution(self, board):
        board_copy = copy.deepcopy(board)
        self.solve(board_copy)
        return board_copy

# Data Class
class SudokuData(BaseSudoku):
    def __init__(self, model):
        super().__init__()
        self.model = model
        self.file_path = None

    def save_game(self, wrong_attempts, cells):
        if self.file_path:
            file_path = self.file_path
        else:
            file_path = filedialog.asksaveasfilename(defaultextension=".txt", filetypes=[("Text Files", "*.txt")])
            if not file_path:
                return False
            self.file_path = file_path

        try:
            with open(file_path, 'w') as file:
                file.write(f"{wrong_attempts}\n")
                for i in range(self.model.BOARD_SIZE):
                    row_data = []
                    for j in range(self.model.BOARD_SIZE):
                        user_input = cells[i][j].get()
                        if user_input and user_input == str(self.model.solution[i][j]):
                            row_data.append(user_input)
                        else:
                            row_data.append('0')
                    file.write(' '.join(row_data) + '\n')
            messagebox.showinfo("Save Game", "เกมถูกบันทึกเรียบร้อยแล้ว!")
            return True
        except Exception as e:
            messagebox.showerror("Error", f"เกิดข้อผิดพลาดในการบันทึกเกม: {e}")
            return False

    def load_game(self):
        file_path = filedialog.askopenfilename(defaultextension=".txt", filetypes=[("Text Files", "*.txt")])
        if not file_path:
            return None

        try:
            with open(file_path, 'r') as file:
                lines = file.readlines()
                if len(lines) < self.model.BOARD_SIZE + 1:
                    messagebox.showerror("Error", "ไฟล์เกมไม่สมบูรณ์หรือผิดรูปแบบ")
                    return None

                wrong_attempts = int(lines[0].strip())
                board = []
                for line in lines[1:self.model.BOARD_SIZE + 1]:
                    board.append(list(map(int, line.strip().split())))
            self.file_path = file_path
            return wrong_attempts, board
        except Exception as e:
            messagebox.showerror("Error", f"เกิดข้อผิดพลาดในการโหลดเกม: {e}")
            return None

# View Class
class SudokuView(BaseSudoku):
    def __init__(self, master, controller):
        super().__init__()
        self.master = master
        self.master.title("Sudoku")
        self.controller = controller

        self.game_frame = tk.Frame(master)
        self.game_frame.pack()

        self.canvas = tk.Canvas(self.game_frame, width=self.CELL_SIZE * self.BOARD_SIZE, 
                                height=self.CELL_SIZE * self.BOARD_SIZE)
        self.canvas.grid(row=0, column=0, columnspan=self.BOARD_SIZE)
        self.create_grid(self.canvas)

        self.cells = self.create_input_fields()
        self.create_game_buttons()
        self.wrong_attempts = 0
        self.create_wrong_attempts_label()

    def create_input_fields(self):
        cells = []
        for i in range(self.BOARD_SIZE):
            row = []
            for j in range(self.BOARD_SIZE):
                var = tk.StringVar()
                vcmd = (self.master.register(self.controller.validate_input), '%P')
                entry = tk.Entry(self.game_frame, width=2, justify='center', font=('Arial', 18),
                                 textvariable=var, validate='key', validatecommand=vcmd)
                entry.place(x=j * self.CELL_SIZE + 5, y=i * self.CELL_SIZE + 5,
                           width=self.CELL_SIZE - 10, height=self.CELL_SIZE - 10)
                var.trace_add('write', lambda name, index, mode, var=var, i=i, j=j: self.controller.validate_cell(var, i, j))
                row.append(entry)
            cells.append(row)
        return cells

    def create_game_buttons(self):
        self.reset_button = self.create_button(self.game_frame, "Reset Game", self.controller.reset_board, row=10, column=4, colspan=2)
        self.save_button = self.create_button(self.game_frame, "Save Game", self.controller.save_game, row=10, column=6, colspan=2)
        self.load_button = self.create_button(self.game_frame, "Load Game", self.controller.load_game, row=10, column=1, colspan=2)

    def create_wrong_attempts_label(self):
        self.wrong_attempts_label = tk.Label(self.game_frame, text=f"ผิดพลาด: {self.wrong_attempts}/{self.MAX_WRONG_ATTEMPTS}", font=('Arial', 12))
        self.wrong_attempts_label.grid(row=10, column=0, padx=10, pady=10, sticky='w')

    def update_wrong_attempts_label(self, wrong_attempts):
        self.wrong_attempts_label.config(text=f"ผิดพลาด: {wrong_attempts}/{self.MAX_WRONG_ATTEMPTS}")

    def update_cells(self, board):
        for i in range(self.BOARD_SIZE):
            for j in range(self.BOARD_SIZE):
                self.cells[i][j].config(state='normal', bg='white')
                self.cells[i][j].delete(0, tk.END)
                if board[i][j] != 0:
                    self.cells[i][j].insert(0, str(board[i][j]))
                    self.cells[i][j].config(state='disabled', disabledforeground='black')

    def reset_colors(self):
        for row in self.cells:
            for cell in row:
                cell.config(bg='white')

# Controller Class
class SudokuController(BaseSudoku):
    def __init__(self, master):
        super().__init__()
        self.model = SudokuModel()
        self.view = SudokuView(master, self)
        self.data = SudokuData(self.model)
        self.game_over = False  # เพิ่มตัวแปรนี้
        self.start_game()

    def start_game(self):
        """เริ่มเกมใหม่"""
        self.model.generate_board()
        self.view.update_cells(self.model.board)
        self.view.reset_colors()
        self.view.wrong_attempts = 0
        self.view.update_wrong_attempts_label(self.view.wrong_attempts)
        self.game_over = False  # รีเซ็ตสถานะเมื่อเริ่มเกมใหม่

    def validate_input(self, value):
        if value == "" or (value.isdigit() and 1 <= int(value) <= 9):
            return True
        return False

    def validate_cell(self, var, row, col):
        value = var.get()
        if value and self.model.solution[row][col] != int(value):
            self.view.cells[row][col].config(bg='red')
            self.view.wrong_attempts += 1
            self.view.update_wrong_attempts_label(self.view.wrong_attempts)
            if self.view.wrong_attempts >= self.MAX_WRONG_ATTEMPTS:
                self.end_game()
                 
        elif value:
            self.view.cells[row][col].config(bg='green')

        if self.check_victory():
            self.end_game_with_victory()

    def check_victory(self):
        """ตรวจสอบว่าผู้เล่นชนะหรือไม่"""
        if self.game_over:  # ตรวจสอบว่าเกมจบหรือไม่
            return False
        for row in range(self.BOARD_SIZE):
            for col in range(self.BOARD_SIZE):
                if self.view.cells[row][col].get() != str(self.model.solution[row][col]):
                    return False
        return True

    def end_game_with_victory(self):
        """จัดการเมื่อผู้เล่นชนะเกม"""
        if not self.game_over:  # ตรวจสอบว่าเกมจบหรือยัง
            messagebox.showinfo("Congratulations!", "คุณชนะเกมนี้!")
            self.view.wrong_attempts = 0  # รีเซ็ตจำนวนความผิดพลาด
            self.view.update_wrong_attempts_label(self.view.wrong_attempts)
            self.game_over = True  # ตั้งค่าสถานะเกมจบ

    def end_game(self):
        messagebox.showinfo("Game Over", "เกมจบแล้ว! คุณแพ้!\nเมื่อคุณกดปุ่ม OK เกมจะเริ่มใหม่")
        self.start_game()

    def reset_board(self):
        self.start_game()

    def save_game(self):
        self.data.save_game(self.view.wrong_attempts, self.view.cells)

    def load_game(self):
        """โหลดสถานะเกม"""
        result = self.data.load_game()
        if result:
            wrong_attempts, board = result
            self.model.board = copy.deepcopy(board)
            self.model.solution = self.model.generate_solution(board)
            self.view.update_cells(self.model.board)
            self.view.reset_colors()

            for i in range(self.model.BOARD_SIZE):
                for j in range(self.BOARD_SIZE):
                    user_input = self.view.cells[i][j].get()
                    if user_input != "" and user_input == str(self.model.solution[i][j]):
                        self.view.cells[i][j].config(bg='green')
                    elif board[i][j] != 0:
                        self.view.cells[i][j].config(bg='white')

            self.view.wrong_attempts = wrong_attempts
            self.view.update_wrong_attempts_label(self.view.wrong_attempts)

            # ตรวจสอบว่าผู้เล่นชนะแล้วหรือไม่
            if self.check_victory():
                self.end_game_with_victory()

            if self.view.wrong_attempts >= self.MAX_WRONG_ATTEMPTS:
                self.end_game()

# Main Function
def main():
    root = tk.Tk()
    SudokuController(root)
    root.mainloop()

if __name__ == "__main__":
    main()
